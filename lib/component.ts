import { defineComponent } from '@vue/composition-api'
import MessageFormat from 'messageformat'
import { parse } from 'messageformat-parser'

import VueICU from './index'

export default defineComponent({
  name: 'ICU',
  functional: true,
  props: {
    path: {
      type: String,
      default: null
    },
    tag: {
      type: String,
      default: 'span'
    },
    variables: {
      type: Object,
      default: () => ({})
    }
  },
  render (h, { props, data, children, parent }) {
    const icu = (parent as Vue & { $icu: VueICU }).$icu
    const message = icu.getMessage(props.path)

    const options = {
      returnType: 'values',
      customFormatters: icu.customFormatters
    }

    const formatter = new MessageFormat(icu.locale, options)
    const fn = formatter.compile(message, icu.locale)

    const parsedMessage = parse(message)
    const sourceIndexes = []

    /**
     * For each variable specified in the props, we will loop through it
     * to find the "index" of each prop in the parsed values.
     */
    Object.keys(props.variables).forEach(attr => {
      const attributePosition = parsedMessage
        .findIndex(token => {
          if (typeof token === 'string') return false

          const tokenTypes = ['argument', 'function']
          return tokenTypes.includes(token.type) && token.arg && token.arg === attr
        })

      if (attributePosition !== -1) {
        sourceIndexes[attributePosition] = parsedMessage[attributePosition]
      }
    })

    const attributes = Object.keys(props.variables).map(key => ([
      key,
      props.variables[key]
    ]))

    /**
     * Since Object.fromEntries is not available here. Loop through the attributes to
     * create the object.
     */
    const objectAttributes = {}
    attributes.forEach(attr => {
      objectAttributes[attr[0]] = attr[1]
    })

    const messageFormatParts = fn({
      ...objectAttributes
    })

    /**
     * For each parts generated by the messageformat, we'll try to find the associated index
     * according to the loop made before. Accordingly, we'll use the scoped slot or just
     * render plain text.
     */
    const vNodes = (messageFormatParts as unknown as Array<string>).map((part, index) => {
      /**
       * Check if the message part index belongs to the source indexes
       */
      if (sourceIndexes[index]) {
        const argName = sourceIndexes[index].arg

        if (data.scopedSlots && data.scopedSlots[argName]) {
          // Use scoped slot
          const slotVNodes = data.scopedSlots[argName]({
            value: props.variables[argName],
            key: (typeof part === 'string' || typeof part === 'number')
              ? part
              : (part as string[]).join('')
          })

          return slotVNodes
        }
      }

      return part // Return plain text, we could eventually return a vNode here
    })

    return h(props.tag, data, [
      ...(children || []),
      ...vNodes
    ])
  }
})
